# π-calculus

- A compiler for untyped π-calculus with a simple C FFI.
- Emits C code and leaves the rest to gcc.
- `cabal run` to build and view command line options.

## Syntax

The following program creates a fresh channel `ch` and then runs two processes in parallel:
- One process constantly reads in characters from stdin using `getchar` and writes them
  to `ch`.
- Another process constantly reads in characters from the channel `ch` and writes them
  to stdout using `putchar`.

```
new ch;
all {
  loop
    x <~ getchar;
    x -> ch.
  loop
    y <- ch;
    do putchar y.
}
```

This program gives a pretty good overview of the syntax:
- `new x; P` is a process which creates a new channel `x` and continues as `P`.
- `all { P .. Q }` runs processes `P` .. `Q` concurrently.
- `loop P` runs process `P` in a loop forever.
- `x <- c; P` reads `x` from channel `c` and continues as `P`.
- `y -> c; P` writes `y` to channel `c` and continues as `P`.
- `x <~ f y .. z; P` calls a C function named `f` with arguments `y` .. `z`, puts the result
    in `x`, and continues as `P`. `y` .. `z` can be themselves nested expressions which represent
    function calls. For example, 
    ```
    loop do getchar (putchar).
    ```
    is a working `cat` program.
- `do f y .. z; P` is similar but ignores the result.

A few things not covered by the above example:
- `any { P .. Q }` randomly chooses one of the processes `P` .. `Q` to run.
- `match x { y => P, .., z => Q }` finds the first variable in `y` .. `z` that
    matches `x` and runs the corresponding process.
- `foreign { ... }` inserts C code directly into the compiled output at global scope.

## Repo map

- [src](https://github.com/johnli0135/pi-calculus/tree/master/src):
    the compiler.
- [runtime](https://github.com/johnli0135/pi-calculus/tree/master/runtime):
    C implementation of green threads and channels for communication.
- [examples](https://github.com/johnli0135/pi-calculus/tree/master/examples):
    some example `pi` programs.
- [scrap](https://github.com/johnli0135/pi-calculus/tree/master/scrap):
    various experiments in C and assembly.
- [sandbox](https://github.com/johnli0135/pi-calculus/blob/master/sandbox):
    misc. notes / todo items.

## Fun facts

- The runtime uses green threads for concurrency, based on
    [this tutorial](https://c9x.me/articles/gthreads/code0.html).
- Communication channels contain a small buffer to allow for 
    multiple threads to make progress even if they all write to the same channel.
    Attempting to read from an empty buffer/write to a full buffer adds the
    current thread to a wait queue, and the waiting thread won't be scheduled until
    it's able to make progress again.
- We perform register allocation even with compilation to C: gcc is good at register allocatin
    but stack locals that need
    to be kept alive across forks have to be explicitly copied from one thread's stack
    to another's. All callee-save registers are reserved for π-calculus locals and
    a naive heuristic tells the allocator to avoid spilling variables that are live
    across many forks.
- Floating ν inwards: since there aren't any mutable variables or complicated
    control flow constructs, liveness analysis is basically the free variable function.
    To make the liveness info generated by the free variable function more precise,
    all νs are floated inwards as far as possible.
